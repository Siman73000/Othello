<p align="center"> <img src="Othello.png" alt="Othello OS icon" width="96" height="96"> </p> <h1 align="center">Othello OS</h1> <p align="center"> <em>Bare-metal x86_64 playground for bootloaders, kernels, and real-time experiments.</em> </p> <p align="center"> <sub> From BIOS reset vector âœ long mode âœ <code>kernel_main()</code>. Minimal, modular, and unapologetically low-level. </sub> </p> <p align="center"> <img alt="arch" src="https://img.shields.io/badge/arch-x86__64-informational?style=for-the-badge"> <img alt="langs" src="https://img.shields.io/badge/languages-Assembly%20%7C%20Rust%20%7C%20C-orange?style=for-the-badge"> <img alt="status" src="https://img.shields.io/badge/status-research%20/%20edu-blueviolet?style=for-the-badge"> <img alt="version" src="https://img.shields.io/badge/version-1.0-success?style=for-the-badge"> </p> <p align="center"> <kbd>Assembly-first boot</kbd> <kbd>Rust kernel</kbd> <kbd>MBR â†’ Stage-2</kbd> <kbd>Real-mode â†’ Long-mode</kbd> </p> <p align="center"> <a href="#overview">Overview</a> Â· <a href="#boot-pipeline">Boot Pipeline</a> Â· <a href="#features--design-goals">Features</a> Â· <a href="#repo-layout">Repo Layout</a> Â· <a href="#getting-started">Getting Started</a> Â· <a href="#hacking-points">Hacking Points</a> Â· <a href="#roadmap--status">Roadmap</a> Â· <a href="#contributing">Contributing</a> </p> <p align="center"> <img src="https://img.shields.io/badge/bootloader-ğŸ§¬%20hand--crafted-informational?style=flat-square"> <img src="https://img.shields.io/badge/kernel-ğŸ¦€%20rust--powered-informational?style=flat-square"> <img src="https://img.shields.io/badge/usecase-ğŸ§ª%20osdev%20lab-informational?style=flat-square"> </p> <div align="center"> <pre> [ BOOT PIPELINE ] BIOS â†’ MBR â†’ Stage-2 Loader â†’ Protected Mode â†’ Long Mode â†’ kernel_main() </pre> </div> <hr /> <h2 id="overview">ğŸ“š Overview</h2> <blockquote> <p> <strong>Othello</strong> is a minimal, hand-crafted operating system written in <strong>x86_64 Assembly</strong>, <strong>Rust</strong>, and <strong>C</strong>.<br /> It demonstrates the complete CPU boot processâ€”from <strong>real mode</strong> through <strong>protected mode</strong> and into <strong>long mode</strong>â€”while providing a CLI and foundations for a GUI. </p> </blockquote> <p>Othello is designed to be:</p> <ul> <li><strong>Educational</strong> â€“ Every stage of the boot process is explicit and inspectable.</li> <li><strong>Modular</strong> â€“ Core subsystems are cleanly separated (GDT, IDT, paging, disk loader, kernel handoff).</li> <li><strong>Simple</strong> â€“ Starts with a flat memory model and identity-mapped paging.</li> <li><strong>Extensible</strong> â€“ Gives you obvious hook points like <code>BEGIN_32BIT</code>, <code>BEGIN_64BIT</code>, and <code>kernel_main</code>.</li> </ul> <br /> <div align="center"> <table> <thead> <tr> <th align="center">ğŸ¯ Project Focus</th> <th align="center">ğŸ§ª Ideal For</th> </tr> </thead> <tbody> <tr> <td valign="top"> <ul> <li>Understanding <strong>BIOS â†’ MBR â†’ long mode</strong> in a real codebase</li> <li>Seeing how <strong>GDT / IDT / paging</strong> glue together</li> <li>Experimenting with <strong>Rust on bare metal</strong></li> </ul> </td> <td valign="top"> <ul> <li>Students learning <strong>OS dev</strong> / computer architecture</li> <li>Hobbyists building custom kernels or RTOS experiments</li> <li>Anyone who wants to step through <strong>every boot stage</strong> on x86_64</li> </ul> </td> </tr> </tbody> </table> </div> <br /> <h3>âœ¨ Why this OS exists</h3> <p> There are plenty of full-featured kernels; <strong>Othello is intentionally not one of them</strong>. Instead, it aims to be a <strong>signal-boosted lab bench</strong> for: </p> <ul> <li>Following the <strong>exact</strong> path from BIOS to 64-bit Rust.</li> <li>Understanding how <strong>GDT / IDT / paging / mode switches</strong> actually work.</li> <li>Experimenting with RTOS-like designs, schedulers, and low-level drivers on a small, readable codebase.</li> </ul> <h3>ğŸ“Š Quick facts</h3> <table> <thead> <tr> <th align="left">Category</th> <th align="left">Details</th> </tr> </thead> <tbody> <tr> <td>Architecture</td> <td>x86_64 (BIOS / MBR boot)</td> </tr> <tr> <td>Boot stages</td> <td>MBR â†’ Stage-2 loader â†’ 32-bit protected mode â†’ 64-bit long mode</td> </tr> <tr> <td>Languages</td> <td>Assembly (bootloader), Rust (kernel), C (support code)</td> </tr> <tr> <td>Kernel entry</td> <td><code>kernel_main</code> (Rust)</td> </tr> <tr> <td>Focus</td> <td>Education, experimentation, research</td> </tr> <tr> <td>Status</td> <td>Early research / hobby OS (not production-ready)</td> </tr> </tbody> </table> <hr /> <h2 id="boot-pipeline">ğŸ§µ Boot Pipeline</h2> <p> Othello is built around the <strong>full mode-transition story</strong>: you can trace what the CPU is doing from reset to Rust. </p> <div align="center"> <pre> [ CPU BOOT STORY ] BIOS (real mode) â†³ MBR @ 0x7C00 (Stage 0) â†³ Stage-1 loader (16-bit) â†³ Stage-2 (32-bit protected mode) â†³ Long mode (64-bit) â†³ Rust kernel: kernel_main() </pre> </div> <p align="center"> <sub><em>From a 512-byte MBR stub to a 64-bit Rust kernel â€” with each transition spelled out.</em></sub> </p> <br /> <h3>ğŸ”¬ Stage-by-stage</h3> <details> <summary><strong>Stage 0 â€“ BIOS â†’ MBR (16-bit real mode)</strong></summary> <ul> <li>BIOS loads a 512-byte MBR at <code>0x7C00</code>.</li> <li>A tiny stub sets up the initial stack and basic disk parameters.</li> <li>Control jumps into the stage-1 loader, still in real mode.</li> </ul> </details> <details> <summary><strong>Stage 1 â€“ Disk loader (16-bit)</strong></summary> <ul> <li>Uses <code>INT 13h</code> extensions to load additional sectors from disk (stage-2 loader + kernel image).</li> <li>Prepares a <strong>GDT</strong> and other state required for entering protected mode.</li> <li>Sets up a clean path to flip the <strong>PE bit</strong> and leave real mode behind.</li> </ul> </details> <details> <summary><strong>Stage 2 â€“ Protected mode bring-up (32-bit)</strong></summary> <ul> <li>Switches into <strong>32-bit protected mode</strong>.</li> <li>Enables <strong>identity-mapped paging</strong> (physical = virtual during early bring-up).</li> <li>Installs descriptor tables and basic interrupt/exception handling stubs.</li> <li>Brings simple text output online so you can log each step of initialization.</li> </ul> </details> <details> <summary><strong>Stage 3 â€“ Long mode &amp; handoff (64-bit)</strong></summary> <ul> <li>Configures long mode paging structures (PML4, PDPT, etc.).</li> <li>Enables long mode and jumps into 64-bit code.</li> <li>Maps the Rust kernel image and calls <code>kernel_main()</code>.</li> <li>From here, the Rust kernel takes over: runtime init, CLI, future GUI and RTOS experiments.</li> </ul> </details> <p> ğŸ” The goal is not to hide complexity but to <strong>encapsulate</strong> it: each stage has a clear purpose, entry point, and exit point, making it easy to instrument or replace. </p> <hr /> <h2 id="features--design-goals">ğŸ§± Features &amp; Design Goals</h2> <table> <thead> <tr> <th align="left">ğŸ“ Educational OS</th> <th align="left">ğŸ§© Modular Layout</th> <th align="left">ğŸ§ª CLI &amp; GUI Foundations</th> </tr> </thead> <tbody> <tr> <td valign="top"> <ul> <li>Exposes every major step of the boot pipeline with <strong>comments over cleverness</strong>.</li> <li>Great for self-study, lab assignments, or â€œI want to see how this really worksâ€.</li> <li>Shows how you get from <strong>BIOS</strong> to <strong>Rust</strong> without an OS in between.</li> </ul> </td> <td valign="top"> <ul> <li>Boot stages, GDT/IDT, and paging live in separate, focused units.</li> <li>Rust kernel with well-defined entry points and initialization steps.</li> <li>Easy to swap out scheduler, allocator, or device drivers.</li> </ul> </td> <td valign="top"> <ul> <li>Text-mode shell for interacting with the running kernel.</li> <li>Framebuffer access and drawing primitives for GUI experiments.</li> <li>Natural path to a tiny desktop or RTOS console for demos.</li> </ul> </td> </tr> </tbody> </table> <hr /> <h2 id="repo-layout">ğŸ“ Repository Layout</h2> <p>The high-level structure of the project:</p> <pre><code>Othello-OS/ â”œâ”€ OS_Build/ # Build orchestration and bootloader / ISO pipeline â”‚ â”œâ”€ BUILDING.md # Detailed build instructions and tooling â”‚ â”œâ”€ boot/ # MBR, stage-2 loader, linker scripts, etc. â”‚ â””â”€ scripts/ # Helper scripts (build, run, ISO packing) â”œâ”€ Rust-Kernel/ # Rust kernel crate (kernel_main, init, drivers) â”‚ â”œâ”€ src/ â”‚ â””â”€ Cargo.toml â””â”€ README.md # You are here </code></pre> <p> The exact layout may evolve; <code>OS_Build/BUILDING.md</code> is the canonical reference for the build system and toolchain expectations. </p> <hr /> <h2 id="getting-started">ğŸš€ Getting Started</h2> <h3>ğŸ§° Prerequisites</h3> <p>Youâ€™ll typically want:</p> <ul> <li><strong>Rust</strong> (with a bare-metal target like <code>x86_64-unknown-none</code>)</li> <li>An <strong>assembler</strong> (e.g. <code>nasm</code> / <code>yasm</code>)</li> <li>A <strong>C toolchain</strong> (<code>gcc</code>, <code>clang</code>, etc.)</li> <li><strong>QEMU</strong> or another x86_64 hypervisor/emulator</li> <li>Shell environment: <ul> <li>Bash / Zsh on Linux/macOS, or</li> <li>PowerShell on Windows</li> </ul> </li> </ul> <p> ğŸ” For exact version hints and platform notes, see <a href="OS_Build/BUILDING.md"><code>OS_Build/BUILDING.md</code></a>. </p> <h3>ğŸ“¦ Clone &amp; build</h3> <pre><code># Clone the repository git clone https://github.com/&lt;your-user&gt;/Othello-OS.git cd Othello-OS # Go to the build orchestration directory cd OS_Build # Build the disk image and run it (Linux/macOS) ./build-and-run.sh # Or on Windows (PowerShell) # ./build-and-run.ps1 </code></pre> <p>Typical build scripts will:</p> <ol> <li>Assemble the bootloader (MBR + stage-2).</li> <li>Compile the Rust/C kernel.</li> <li>Link everything into a flat binary.</li> <li>Produce a bootable disk image or El Torito ISO.</li> <li>Launch QEMU with that image.</li> </ol> <p> For the <strong>authoritative instructions</strong>, always refer to <a href="OS_Build/BUILDING.md"><code>OS_Build/BUILDING.md</code></a>. </p> <hr /> <h2 id="hacking-points">ğŸ›  Hacking Points</h2> <p>Use Othello as a <strong>sandbox</strong> rather than a black box. Good entry points:</p> <h3>ğŸ”§ Bootloader &amp; mode switching</h3> <ul> <li><code>BEGIN_32BIT</code> â€“ where CR0 gets flipped and the CPU enters protected mode.</li> <li><code>BEGIN_64BIT</code> â€“ where long mode paging is set up and control jumps to 64-bit code.</li> <li>BIOS disk routines â€“ experiment with: <ul> <li>CHS vs LBA addressing,</li> <li>loading different sectors,</li> <li>extra error handling and debugging output.</li> </ul> </li> </ul> <h3>ğŸ§  Kernel &amp; runtime</h3> <ul> <li><code>kernel_main()</code> â€“ central execution entry in Rust, ideal for: <ul> <li>a custom scheduler,</li> <li>a tiny task system,</li> <li>a REPL-style kernel shell.</li> </ul> </li> <li>Early initialization â€“ stack, heap allocator, panic handler, debug prints.</li> </ul> <h3>ğŸ§­ Memory &amp; interrupts</h3> <ul> <li><code>init_gdt()</code> â€“ GDT setup; try new segments or different privilege levels.</li> <li><code>init_idt()</code> â€“ IDT entries; attach custom handlers to CPU exceptions.</li> <li><code>init_paging()</code> â€“ identity mapping first; extend to: <ul> <li>higher-half kernel,</li> <li>user/kernel split,</li> <li>per-task address spaces.</li> </ul> </li> </ul> <hr /> <h2 id="roadmap--status">ğŸ—º Roadmap &amp; Status</h2> <p> This is a <strong>research / education OS</strong>, not a production operating system. Expect rough edges & experimental branches. </p> <h3>Short-term</h3> <ul> <li>Polish boot-stage logs and error codes.</li> <li>Stabilize CLI commands for inspecting registers, memory maps, and page tables.</li> <li>Harden interrupt/exception handling paths.</li> </ul> <h3>Medium-term</h3> <ul> <li>Add a minimal scheduler + task abstraction.</li> <li>Introduce a simple filesystem driver for loading user programs.</li> <li>Flesh out framebuffer-based GUI (basic windows/widgets).</li> </ul> <h3>Long-term / Experimental</h3> <ul> <li>Explore RTOS-style scheduling for soft real-time workloads.</li> <li>Bring up multi-core (SMP) and inter-CPU communication.</li> <li>Implement more advanced memory management: <ul> <li>higher-half kernel,</li> <li>isolated user space,</li> <li>per-process virtual memory.</li> </ul> </li> </ul> <hr /> <h2 id="contributing">ğŸ¤ Contributing</h2> <p> Contributions that improve <strong>clarity</strong>, <strong>documentation</strong>, or <strong>low-level tooling</strong> are very welcome: </p> <ul> <li>Keep PRs small and focused (one subsystem or concern at a time).</li> <li>Favor comments that explain <strong>why</strong> a low-level sequence exists, not just what it does.</li> <li>For larger architectural changes, please start a discussion in an issue first.</li> </ul> <p> If you use Othello in a course, lab, or research project, feel free to open an issue with a short write-up â€” itâ€™s genuinely helpful to know what the OS is being used for. </p> <h2 id="code-of-conduct">ğŸ“œ Code of Conduct</h2> <p> This project is governed by a <strong>Code of Conduct</strong>. By participating in the issue tracker, discussions, or pull requests, you agree to follow it. </p> <p> â¡ï¸ See: <a href="CODE_OF_CONDUCT.md"><code>CODE_OF_CONDUCT.md</code></a> </p> <h2 id="license">âš–ï¸ License</h2> <p> This project is licensed under the terms specified in the <a href="LICENSE"><code>LICENSE</code></a> file in this repository. </p> <p> You are encouraged to read the license before reusing or redistributing any part of the code, and to reference this repository if you build derivative or educational material on top of it. </p> ::contentReference[oaicite:0]{index=0}